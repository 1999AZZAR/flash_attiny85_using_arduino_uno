# ATtiny85 Multi-Mode Example

A sophisticated state-machine example demonstrating non-blocking multitasking, hardware timers, and interrupt handling.

## Description
This program implements a single-button controller that cycles through 4 distinct modes. Unlike previous examples, this code is **non-blocking**:
*   The button remains responsive even while the LED is fading or blinking.
*   System timing is handled by a background interrupt timer (Timer1).
*   LED patterns are generated by hardware PWM (Timer0).

## Modes (Cycle on Click)
0.  **OFF**: LED is disabled.
1.  **ON**: LED is solid on (100% brightness).
2.  **BLINK**: LED blinks at 2Hz (250ms interval).
3.  **BREATHE**: LED smoothly fades in and out.

## Hardware Connection

| ATtiny85 Pin | Component | Connection |
|---|---|---|
| **Pin 5 (PB0)** | LED | Anode to Pin 5, Cathode to GND (via 220Î© Resistor) |
| **Pin 2 (PB3)** | Push Button | One leg to Pin 2, other leg to GND |
| **Pin 8 (VCC)** | Power | 2.7V - 5.5V |
| **Pin 4 (GND)** | Ground | Common Ground |

## Technical Highlights

### 1. Dual Timer Architecture
The ATtiny85 has two timers, and we use both simultaneously:
*   **Timer0 (8-bit)**: Configured for Fast PWM to drive the LED brightness directly.
*   **Timer1 (8-bit)**: Configured in CTC mode to trigger an interrupt every 1ms. This creates a precise system "heartbeat" (`sys_tick`) used for all timing logic.

### 2. Non-Blocking State Machine
The `main()` loop never stops. It constantly checks the button state (`handle_button()`) and updates the LED (`handle_led()`) based on the current time and mode.
*   **Debounce**: Implemented without `delay()`. The code notes the time of a state change and only accepts it if it remains stable for 50ms.
*   **Task Scheduling**: The Blink and Breathe modes check `millis() - last_update >= INTERVAL` to determine when to run, allowing other tasks to execute in between.

## Build and Flash

```bash
# Compile and Upload
make flash
```
